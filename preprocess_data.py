# -*- coding: utf-8 -*-
"""oversampling

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lzr_MEKsjEuYRb74Mu3QFh6UlkEXV9sQ
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import random
import cv2
from tqdm import tqdm
import os
import random
import numpy as np
from tqdm import tqdm
from keras.preprocessing.image import ImageDataGenerator
from PIL import Image
import shutil
import os
import random
from PIL import Image
from torchvision import transforms
import time

target_size = (512, 512)
# Function to perform image augmentation
def augment_image(image):
    # Apply your augmentation techniques here
    # Example: flipping, rotation, brightness adjustment, etc.
    # Remember to return the augmented image
    image = np.array(image)
    image = Image.fromarray(image)
    augmenter = transforms.Compose([
        #transforms.RandomResizedCrop(target_size),
        transforms.RandomHorizontalFlip(),
        transforms.RandomRotation(15),
        transforms.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2, hue=0.1)
    ])

    return augmenter(image.copy())

def augment_images_in_directory(input_dir, output_dir, min_samples=200):
    # Iterate through each class directory
    for class_name in os.listdir(input_dir):
        class_dir = os.path.join(input_dir, class_name)
        output_class_dir = os.path.join(output_dir, class_name)
        os.makedirs(output_class_dir, exist_ok=True)
        images = [f for f in os.listdir(class_dir) if True]
        how = 0
        while True:
                # Collect all image filenames in the class directory
                imgs = [f for f in os.listdir(output_class_dir) if True]

                # Check if number of images is less than minimum required
                if len(images)+len(imgs) < min_samples:
                    # Calculate how many images need to be augmented
                    num_augment = min_samples - len(images) - len(imgs)

                    # Randomly select images to augment
                    images_to_augment = []
                    while num_augment > 0:
                        a = random.sample(images, min(num_augment, len(images)))
                        images_to_augment.extend(a)
                        num_augment -= len(a)


                    # Perform augmentation and save the augmented images
                    for img_name in tqdm(images_to_augment, desc=f"Augmenting {class_name}"):
                        img_path = os.path.join(class_dir, img_name)
                        img = cv2.imread(img_path)

                        # Augment the image
                        augmented_img = augment_image(img)

                        # Save the augmented image
                        augmented_img_name = img_name.split('.')[0] + str(how)+'_augmented.' + img_name.split('.')[-1]
                        how += 1
                        output_img_path = os.path.join(output_class_dir, augmented_img_name)
                        augmented_img = np.array(augmented_img)


                        cv2.imwrite(output_img_path, augmented_img)
                else :
                    break

        # Copy original images to the output directory
        for img_name in tqdm(images, desc=f"Copying original {class_name} images"):
            img_path = os.path.join(class_dir, img_name)
            output_img_path = os.path.join(output_class_dir, img_name)
            # Copy the original image to the output directory
            os.system(f'cp "{img_path}" "{output_img_path}"')
        print('Completed ' + class_name)

input_directory = "/content/drive/MyDrive/Guava Dataset (Original Image)"
output_directory = "/content/drive/MyDrive/200_data(Guava)"
os.makedirs(output_directory, exist_ok=True)
shutil.rmtree(output_directory)
time.sleep(30)
augment_images_in_directory(input_directory, output_directory)